#include "ocStack.oh"
#include <math.h>

static void oBoolCopy (obliv bool* dest, const obliv bool* src, size_t boolCount) obliv {
	int i;
	for(i=0; i<boolCount; i++){
		dest[i] = src[i];
	}
}

//calloc defaults values to 0
static ocStack* ocStackCreate(int n, int level, int itemSize){
    if(n<=0)
        return NULL;
    int blockSize = pow(2,level);
    ocStack* s = calloc(1, sizeof (ocStack));
    s->itemSize = itemSize;
    s->level = level;
    s->buffer = calloc(1, 5*itemSize*blockSize*(sizeof (obliv bool)));
    s->next = ocStackCreate(n - 3*blockSize, level+1, itemSize); //to fill 3/5 spaces
    return s;
}

ocStack* ocStackNew(int n, int itemSize){
    return ocStackCreate(n,0, itemSize);
}

//Assume stack already allocated with enough space
static void fillFromList(ocStack* s, obliv bool data[], int lim, int level, int itemSize){
    if(lim<=0)
        return;
    s->level = level;
    s->head = 3;
    int blockSize = pow(2,level);
    oBoolCopy(s->buffer, data, 3*itemSize*blockSize);
    s->maxSize = 3;
    fillFromList(s->next, data+3*blockSize, lim-3*blockSize, ++level, itemSize);
}

ocStack* ocStackFromList(obliv bool data[], int lim, int itemSize){
    ocStack* s = ocStackNew(lim, itemSize);//all buffers fill to 3/5 blocks
    fillFromList(s, data, lim, 0, itemSize); 
    return s;
}

//cap is not implemented. TODO
void capLength(ocStack *s, int cap){
    s->cap = cap; 
    if(s->next!=NULL && cap>1) 
        capLength(s->next, (cap-2)/2);
}

void peek(obliv bool* dest, frozen ocStack *s){
    int i;
    for(i=0; i < 5; i++){
        obliv if(i==(s->head-1)){
            int i;
            oBoolCopy(dest, s->buffer+i*s->itemSize, s->itemSize);
        }
    }
}

//Test for edge cases, null or not enough to shift.
static void shiftLeft(frozen ocStack *s){
    s->popCount=0;
    //if next is null, do nothing.
    if(s->next==NULL)
        return;
    int level = s->level;
    int nxtBlockSize = pow(2,level+1);
    int curBlockSize = pow(2,level);
    obliv if(s->head<2){
        obliv if(s->next->head>0){//perform shift
            int i,j;
            for(i=0; i < 5; i++){
                for(j=0; j < 5; j++){
                    obliv if(i==s->head){
                        obliv if(j==s->next->head-1){
                            oBoolCopy(s->buffer+i * curBlockSize * s->itemSize,
                                    s->next->buffer+j * nxtBlockSize * s->next->itemSize, 
                                    nxtBlockSize*s->itemSize);
                        }
                    }
                }
            }
            s->head+=2;
            s->next->head--;
        }
    }
    s->next->popCount++;
    if(s->next->popCount>=2)
        shiftLeft(s->next);
}

//assume there is space to shift into, and buffers have been allocated
static void shiftRight(frozen ocStack *s){
    s->pushCount=0;
    //if next is null, do nothing.
    if(s->next==NULL)
        return;
    int level = s->level;
    int nxtBlockSize = pow(2, level+1);
    int curBlockSize = pow(2, level);
    obliv if(s->head<2){
        obliv if(s->next->head<5){
            int i,j;
            for(i=0; i < 5; i++){
                for(j=0; j < 5; j++){
                    obliv if(i==s->head-1){
                        obliv if(j==s->next->head){
                            oBoolCopy(s->next->buffer+j * nxtBlockSize * s->next->itemSize, 
                                    s->buffer+i * curBlockSize * s->itemSize, 
                                    nxtBlockSize*s->itemSize);
                            s->head-=2;
                            s->next->head++;
                        }
                    }
                }
            }
        }
    }
    s->next->pushCount++;
    if(s->next->pushCount>=2)
        shiftRight(s->next);
}

void pop(obliv bool* dest, frozen ocStack *s) obliv{
    ~obliv(cond){
        obliv if(cond){
            int i;
            for(i=0; i < 5; i++){
                obliv if(i==(s->head-1)){
                    oBoolCopy(dest, s->buffer+i*s->itemSize, s->itemSize);
                }
            }
            s->head--;
        }
        s->popCount++;
        if (s->popCount>=2)
            shiftLeft(s);
    }
}

void modifyTop(frozen ocStack *s, obliv bool* b) obliv{
    ~obliv(cond){
        obliv if(cond){
            for(int i=0; i < 5; i++){
                obliv if(i==(s->head-1)){
                    oBoolCopy(s->buffer+i*s->itemSize, b, s->itemSize);
                }
            }
        }
    }
}

static void incMax(frozen ocStack *s){
    int bufSlots = 5*pow(2,s->level);
    if(s->maxSize<4)
        s->maxSize++;
    else{
        if(s->next == NULL){
            s->next = calloc(1, sizeof (ocStack));
            s->next->buffer = calloc(1, bufSlots*(sizeof (obliv bool)));
            s->next->level = s->level++;
            if(s->cap>1)
                s->next->cap = (s->cap-2)/2;
        }
        s->maxSize-=2;
        incMax(s->next);
    }
}

void push(frozen ocStack *s, obliv bool* b) obliv{
    ~obliv(cond){
        incMax(s); //also allocated extra space if required.
        obliv if(cond){
            int i;
            for(i=0; i < 5; i++){
                obliv if(i==(s->head)){
                    oBoolCopy(s->buffer+i*s->itemSize, b, s->itemSize);
                }
            }
            s->head++;
        }
        s->pushCount++;
        if (s->pushCount>=2)
            shiftRight(s);
    }
}
void ocStackRelease(ocStack* s){
    if(s->next != NULL)
        ocStackRelease(s->next);
    free(s->buffer);
    free(s);
}
